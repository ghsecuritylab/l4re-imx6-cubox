<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>L4Re - L4 Runtime Environment: test.mk - Test Application Role</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="l4re.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">L4Re - L4 Runtime Environment
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('bid_role_test.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">test.mk - Test Application Role </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The test role is very similar to the application role, it also builds an executable binary.</p>
<p>The difference is that is also builds for each target a test script that executes the test target either on the host (MODE=host) or a target platform (currently only qemu).</p>
<p>The role accepts all make variables that are accepted by the application role. The only difference is that the <code>TARGET</code> variable is not required. If it is missing, the source directory will be scanned for source files that fit the pattern <code>test_*.c[c]</code> and create one target for each of them.</p>
<dl class="section note"><dt>Note</dt><dd>It is possible to still use SRC_C[C] when targets are determined automatically. In that case the specified sources will be used in addition* to the main <code>test_*.c[c]</code> source.</dd></dl>
<p>In addition to the variables above, there are a number of variables that control how the test is executed. All these variables may be used as a global variable that applies to all test or, if the target name is added as a suffix, set for a specific target only.</p>
<dl class="section user"><dt>TEST_TARGET</dt><dd>Name of binary containing the test (default: same as <code>TARGET</code>).</dd></dl>
<dl class="section user"><dt>TARGET_$(ARCH)</dt><dd>When TARGET is undefined, these targets are added to the list of targets for the specified architecture. For all targets <code>SRC_C[C]</code> files must be defined separately.</dd></dl>
<dl class="section user"><dt>TEST_EXPECTED</dt><dd>File containing expected output. By default the variable is empty, which means the test binary is expected to produce TAP test output, that can be directly processed.</dd></dl>
<dl class="section user"><dt>TEST_EXPECTED_REPEAT</dt><dd>Number of times the expected output should be repeated, by default 1. When set to 0 then output is expected to repeat forever. This is particularly useful to make sure that stress tests that are meant to run in an endless loop are still alive. Note that such endless tests can only be run by directly executing the test script. They will be skipped when run in a test harness like <code>prove</code>.</dd></dl>
<dl class="section user"><dt>TEST_TIMEOUT</dt><dd>Non-standard timeout after which the test run is aborted (useful for tests involving sleep).</dd></dl>
<dl class="section user"><dt>NED_CFG</dt><dd>LUA configuration file for startup to give to Ned</dd></dl>
<dl class="section user"><dt>REQUIRED_MODULES</dt><dd>Additional modules needed to run the test.</dd></dl>
<dl class="section user"><dt>QEMU_ARGS</dt><dd>Additional parameters to supply to QEMU.</dd></dl>
<dl class="section user"><dt>MOE_ARGS</dt><dd></dd></dl>
<p>Additional parameters to supply to moe.</p>
<dl class="section user"><dt>KERNEL_CONF</dt><dd>Features the Fiasco kernel must have been compiled with. A space-separated list of config options as used by Kconfig. <code>run_test</code> looks for a <code>globalconfig.out</code> file in the same directory as the kernel and checks that all options are enabled. If not, the test is skipped. Has only an effect if the <code>globalconfig.out</code> file is present.</dd></dl>
<dl class="section user"><dt>L4LINUX_CONF</dt><dd>Features the L4Linux kernel must have been compiled with. Similar to <code>KERNEL_CONF</code> but checks for a <code>.config</code> file in the directory of the L4Linux kernel.</dd></dl>
<dl class="section user"><dt>TEST_SETUP</dt><dd>Command to execute before the test is run. The test will only be executed if the command returns 0. If the exit code is 2, the test is marked as skipped with the reason provided in the final line of stdout.</dd></dl>
<dl class="section user"><dt>TEST_LOGFILE</dt><dd>Append output of test execution to the given file unless TEST_WORKDIR is given.</dd></dl>
<dl class="section user"><dt>TEST_WORKDIR</dt><dd>Create logs, temp and other files below the given directory. That directory is taken as base dir for more automatically created subdir levels using the current test path, in order to guarantee conflict-free usage when running many different tests with a common workdir. When TEST_WORKDIR is provided then TEST_LOGFILE is ignored as it is organized below workdir.</dd></dl>
<dl class="section user"><dt>TEST_TAGS</dt><dd>Comma separated list of tags which have to be specified in order to run the test. Test will be skipped without error otherwise. Useful to mark tests, e.g. broken or slow. Tag names can basically contain any character except comma. Whitespace characters surrounding a tag name will be ignored. A tag starting with exclamation mark is checked to not appear in the specified run tags, otherwise the test is also skipped.</dd></dl>
<p>In addition to compiled tests, it is also possible to create tests where the test binary or script comes from a different source. These tests must be listed in <code>EXTRA_TARGET</code> and for each target a custom <code>TEST_TARGET</code> must be provided.</p>
<h2>Running Tests </h2>
<p>The make role creates a test script which can be found in <code>&lt;builddir&gt;/test/t/&lt;arch&gt;/&lt;api&gt;</code>. It is possible to organise the tests further in subdirectories below by specifying a TEST_GROUP.</p>
<p>To be able to execute the test, a minimal test environment needs to be set up by exporting the following environment variables:</p>
<dl class="section user"><dt>KERNEL_&lt;arch&gt;, KERNEL</dt><dd>Fiasco kernel binary to use. The test runner is able to check if the kernel has all features necessary for the test and skip tests accordingly. In order for this to work, the <code>globalconfig.out</code> config file from the build directory needs to be available in the same directory as the kernel.</dd></dl>
<dl class="section user"><dt>L4LX_KERNEL_&lt;arch&gt;, L4_LX_KERNEL</dt><dd>L4Linux binary to use. This is only required to run tests in <code>mode=l4linux</code>. If no L4Linux kernel is set then these tests will simply be skipped. The test runner is also able to check if the kernel has all features compiled in that are required to run the test successfully (see make variable <code>L4LINUX_CONF</code> above). For this to work, the <code>.config</code> configuration file from the build directory needs to be available in the same directory as the kernel.</dd></dl>
<dl class="section user"><dt>LINUX_RAMDISK_&lt;arch&gt;, LINUX_RAMDISK</dt><dd>Ramdisk to mount as root in L4Linux. This is only required to run tests in <code>mode=l4linux</code>. If not supplied, L4Linux tests will be skipped. The ramdisk must be set up to start the test directly after the initial startup is finished. The name of the test binary is supplied via the kernel command line option <code>l4re_testprog</code>. The <code>tool/test</code> directory contains an example script <code>launch-l4linux-test</code>. which can be copied onto the ramdisk and started by the init script.</dd></dl>
<p>In addition to these variables, the following BID variables can be overwritten at runtime: <code>PT</code> (for the plaform type) and <code>TEST_TIMEOUT</code>. You may also supply <code>QEMU_ARGS</code> and <code>MOE_ARGS</code> which will be appended to the parameters specified in the BID test make file.</p>
<p>Once the environment is set up, the tests can be run either by simply executing all of them from the build directory with </p><pre class="fragment">make test
</pre><p>or executing them directly, like </p><pre class="fragment">test/t/amd64_amdfam10/l4f/l4re-core/moe/test_namespace.t
</pre><p>or running one or more tests through the test harness <a href="http://perldoc.perl.org/prove.html">prove</a>, like </p><pre class="fragment">prove test/t/amd64_amdfam10/l4f/l4re-core/moe/test_namespace.t
prove -r test/t/amd64_amdfam10/l4f/l4re-core/
prove -rv test/t/amd64_amdfam10/l4f/l4re-core/
</pre><p>To run tests with tags (see <code>TEST_TAGS</code>), these tags need to be specified either in the environment variable <code>TEST_RUN_TAGS</code> or as arguments to the test.t files: </p><pre class="fragment">$ test/t/amd64_amdfam10/l4f/l4re-core/test_one.t --run-tags slow,gtest-shuffle
$ test/t/amd64_amdfam10/l4f/l4re-core/test_one.t -T slow,gtest-shuffle
$ prove -r test/t/amd64_amdfam10/l4f/l4re-core/ :: -T slow,gtest-shuffle
$ TEST_RUN_TAGS=slow,gtest-shuffle prove -r test/t/amd64_amdfam10/l4f/l4re-core/
</pre><p>Without providing run tags, tests requiring certain tags are skipped: </p><pre class="fragment">$ make test
...
test/t/amd64_amdfam10/test_one.t .... ok
test/t/amd64_amdfam10/test_two.t .... skipped: requires additional run tags: slow
test/t/amd64_amdfam10/test_three.t .. ok
</pre><p>When tags are provided, the tests requiring those tags are now also executed, the tests that forbid them are skipped: </p><pre class="fragment">$ TEST_RUN_TAGS=slow,gtest-shuffle
$ make test
...
test/t/amd64_amdfam10/test_one.t .... ok
test/t/amd64_amdfam10/test_two.t .... ok
test/t/amd64_amdfam10/test_three.t .. skipped: not supported with run tags: gtest-shuffle
</pre><p>Tests without any tags are always executed.</p>
<h2>Running Tests in External Programs </h2>
<p>You can hand-over test execution to an external program by setting the environment variable <code>EXTERNAL_TEST_STARTER</code> to the full path of that program: </p><pre class="fragment">export EXTERNAL_TEST_STARTER=/path/to/external/test-starter
make test
</pre><dl class="section user"><dt>EXTERNAL_TEST_STARTER</dt><dd></dd></dl>
<p>This variable is evaluated by <code>tool/bin/run_test</code> (the backend behind <code>make test</code>) and contains the full path to the tool which actually starts the test instead of the test itself.</p>
<p>The <code>EXTERNAL_TEST_STARTER</code> can be any program instead of the default execution via <code>make qemu E=maketest</code>. Its output is taken by <code>run_test</code> as the test output.</p>
<p>Usually it is just a bridge to prepare the test execution, e.g., it could create the test as image and start that image via a simulator.</p>
<h3>Running Tests in a Simulator</h3>
<p>Based on above mechanism there is a dedicated external test starter <code>tool/bin/teststarter-image-telnet.pl</code> shipped in BID which assumes an image to be started with another program which provides test execution output on a network port.</p>
<p>This can be used to execute tests in a simulator, like this: </p><pre class="fragment">export EXTERNAL_TEST_STARTER=$L4RE_SRC/tool/bin/teststarter-image-telnet.pl
export SIMULATOR_START=/path/to/configured/simulator-exe
make test
</pre><p>After building the image and starting the simulator it contacts the simulator via a network port (sometimes called "telnet" port) to pass-through its execution output as its own output so it gets captured by <code>run_test</code> as usual.</p>
<p>The following variables control <code>teststarter-image-telnet.pl</code>:</p>
<dl class="section user"><dt>SIMULATOR_START</dt><dd>This points to the full path of the program that actually starts the prepared test image. Most often this is the frontend script of your simulator environment which is pre-configured so that it actually works in the way that <code>teststarter-image-telnet.pl</code> expects from the following settings.</dd></dl>
<dl class="section user"><dt>SIMULATOR_IMAGETYPE</dt><dd>The image type to be generated via <code>make $SIMULATOR_IMAGETYPE E=maketest</code>. Default is <code>elfimage</code>.</dd></dl>
<dl class="section user"><dt>SIMULATOR_HOST</dt><dd>The simulator will be contacted via socket on that host to read its output. Default is <code>localhost</code>.</dd></dl>
<dl class="section user"><dt>SIMULATOR_PORT</dt><dd>The simulator will be contacted via socket on that port to read its output. Default is <code>11111</code>.</dd></dl>
<dl class="section user"><dt>SIMULATOR_START_SLEEPTIME</dt><dd>After starting the simulator it waits that many seconds before reading from the port. Default is <code>1</code> (second).</dd></dl>
<h2>Running tests without tapper-wrapper </h2>
<p>In case you want to replace the tapper-wrapper test starter, you can replace the default one by setting the environment variable <code>TEST_STARTER</code> to the path of your test starter. Then your test starter can use the same environment which is normally set up for the default starter, which includes environment variables provided by the build system as well as the test itself. Among these are <code>SEARCHPATH</code>, <code>MODE</code>, <code>ARCH</code>, <code>MOE_CFG</code>, <code>MOE_ARGS</code>, <code>TEST_TIMEOUT</code>, <code>TEST_TARGET</code>, <code>TEST_EXPECTED</code>, <code>QEMU_ARGS</code> and many more.</p>
<h2>Debugging Tests </h2>
<p>The test script is only a thin wrapper that sets up the test environment as it was defined in the make file and then executes two scripts: <code>tapper-wrapper</code> and <code>run_test</code>.</p>
<p>The main work horse of the two is <code>tool/bin/run_test</code>. It collects the necessary files and starts qemu to execute the test. This script is always required.</p>
<p>There is then a second script wrapped around the test runner: <code>tool/bin/tapper-wrapper</code>. This tool inspects the output of the test runner and reformats it, so that it can be read by tools like <code>prove</code>. If the test produces tap output, then the script scans for this output and filters away all the debug output. If <code>TEST_EXPECTED</code> was defined, then the script scans the output for the expected lines and prints a suitable TAP message with success or failure. It also makes sure that qemu is killed as soon as the test is finished.</p>
<p>There are a number of command-line parameters that allow to quickly change test parameters for debugging purposes. Run the test with '&ndash;help' for more information about available parameters. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="l4re_concepts.html">Programming for L4Re</a></li><li class="navelem"><a class="el" href="l4re_build_system.html">L4Re Build System</a></li>
    <li class="footer">Generated on Sun Nov 25 2018 13:45:54 for L4Re - L4 Runtime Environment by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
