<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>L4Re - L4 Runtime Environment: Uvmm, the virtual machine monitor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="l4re.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">L4Re - L4 Runtime Environment
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('l4re_servers_uvmm.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Uvmm, the virtual machine monitor </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Setting up guest memory </h2>
<p>In the most simple setup, memory for the guest can be provided via a simple dataspace. In your ned script, create a new dataspace of the required size and hand it into uvmm as the <code>ram</code> capability: </p><pre class="fragment">local ramds = L4.Env.user_factory:create(L4.Proto.Dataspace, 60 * 1024 * 1024)

L4.default_loader::startv({caps = {ram = ramds:m("rw")}}, "rom/uvmm")
</pre><p>The memory will be mapped to the most appropriate place and a memory node added to the device tree, so that the guest can find the memory.</p>
<p>For a more complex setup, the memory can be configured via the device tree. uvmm scans for memory nodes and tries to set up the memory from them. A memory device node should look like this: </p><pre class="fragment">memory@0 {
  device_type = "memory";
  reg = &lt;0x00000000 0x00100000
         0x00200000 0xffffffff&gt;;
  l4vmm,dscap = "memcap";
  l4vmm,physmap;
  dma-ranges = &lt;&gt;;
};
</pre><p>The <code>device_type</code> property is mandatory and needs to be set to <code>memory</code>.</p>
<p><code>l4vmm,dscap</code> contains the name of the capability containing the dataspace to be used for the RAM. <code>reg</code> describe the memory regions to use for the memory. The regions will be filled up to the size of the supplied dataspace. If they are larger, then the remaining area will be cut.</p>
<p><code>l4vmm,physmap</code> indicates that uvmm should try to map the dataspace to its actual physical address when no IOMMU is available. If the physical address cannot be determined or an IOMMU is available, then the memory will be mapped to the addresses supplied in <code>regs</code>. It is possible to omit the <code>regs</code> property when <code>l4vmm,physmap</code> is set. In this case, uvmm will fail to start if the physical address cannot be determined.</p>
<p>If a <code>dma-ranges</code> property is given, the host-physical address ranges for the memory regions will be added here. Note that the property is not cleared first, so it should be left empty.</p>
<h3>Memory layout</h3>
<p>uvmm populates the RAM with the following data:</p>
<ul>
<li>kernel binary</li>
<li>(optional) ramdisk</li>
<li>(optional) device tree</li>
</ul>
<p>The kernel binary is put at the predefined address. For ELF binaries, this is an absolute physical address. If the binary supports relative addressing, the binary is put to the requested offset relative to beginning of the first 'memory' region defined in the device tree.</p>
<p>The ramdisk and device tree are placed as far as possible to the end of the regions defined in the first 'memory' node.</p>
<p>If there is a part of RAM that must remain empty, then define an extra memory node for it in the device tree. uvmm only writes to memory in the first memory node it finds.</p>
<p>Warning: uvmm does not touch any unpopulated memory. In particular, it does not ensure that the memory is cleared. It is the responsibility of the provider of the RAM dataspace to make sure that no data leakage can happen. Normally this is not an issue because dataspaces are guaranteed to be cleaned when they are newly created but users should be careful when reusing memory or dataspaces, for example, when restarting the uvmm.</p>
<h2>Forwarding hardware resources to the guest </h2>
<p>Hardware resources must be specified in two places: the device tree contains the description of all hardware devices the guest could see and the Vbus describes which resources are actually available to the uvmm.</p>
<p>The vbus allows the uvmm access to hardware resources in the same way as any other <a class="el" href="namespaceL4.html" title="L4 low-level kernel interface. ">L4</a> application. uvmm expects a capability named 'vbus' where it can access its hardware resources. It is possible to leave out the capability for purely virtual guests (Note that this is not actually practical on some architectures. On ARM, for example, the guest needs hardware access to the interrupt controller. Without a 'vbus' capability, interrupts will not work.) For information on how to configure a vbus, see the <a class="el" href="io.html">IO documentation</a>.</p>
<p>The device tree needs to contain the hardware description the guest should see. For hardware devices this usually means to use a device tree that would also be used when running the guest directly on hardware.</p>
<p>On startup, uvmm scans the device tree for any devices that require memory or interrupt resources and compares the required resources with the ones available from its vbus. When all resources are available, it sets up the appropriate forwarding, so that the guest now has direct access to the hardware. If the resources are not available, the device will be marked as 'disabled'. This mechanism allows to work with a standard device tree for all guests in the system while handling the actual resource allocation in a flexible manner via the vbus configuration.</p>
<p>The default mechanism assigns all resources 1:1, i.e. with the same memory address and interrupt number as on hardware. It is also possible to map a hardware device to a different location. In this case, the assignment between vbus device and device tree device must be known in advance and marked in the device tree using the <code>l4vmm,vbus-dev</code> property.</p>
<p>The following device will for example be bound with the vbus device with the HID 'l4-test,dev': </p><pre class="fragment">test@e0000000 {
    compatible = "memdev,bar";
    reg = &lt;0 0xe0000000 0 0x50000&gt;,
          &lt;0 0xe1000000 0 0x50000&gt;;
    l4vmm,vbus-dev = "l4-test,dev";
    interrupts-extended = &lt;&amp;gic 0 139 4&gt;;
};
</pre><p>Resources are then matched by name. Memory resources in the vbus must be named <code>reg0</code> to <code>reg9</code> to match against the address ranges in the device tree <code>reg</code> property. Interrupts must be called <code>irq0</code> to <code>irq9</code> and will be matched against <code>interrupts</code> or <code>interrupts-extended</code> entries in the device tree. The vbus must expose resources for all resources defined in the device tree entry or the initialisation will fail.</p>
<p>An appropriate IO entry for the above device would thus be: MEM = Io.Hw.Device(function() Property.hid = "l4-test,dev" Resource.reg0 = Io.Res.mmio(0x41000000, 0x4104ffff) Resource.reg1 = Io.Res.mmio(0x42000000, 0x4204ffff) Resource.irq0 = Io.Res.irq(134); end)</p>
<p>Please note that HIDs on the vbus are not necessarily unique. If multiple devices with the HID given in <code>l4vmm,vbus-dev</code> are available on the vbus, then one device is chosen at random.</p>
<p>If no vbus device with the given HID is available, the device is disabled.</p>
<h2>How to enable guest suspend/resume </h2>
<dl class="section note"><dt>Note</dt><dd>Currently only supported on ARM. It should work fine with Linux version 4.4 or newer.</dd></dl>
<p>Uvmm (partially) implements the power state coordination interface (PSCI), which is the standard ARM power management interface. To make use of this interface, you have to announce its availability to the guest operating system via the device tree like so: </p><pre class="fragment">psci {
      compatible = "arm,psci-0.2";
      method = "hvc";
};
</pre><p>The Linux guest must be configured with at least these options: </p><pre class="fragment">CONFIG_SUSPEND=y
CONFIG_ARM_PSCI=y
</pre><h2>How to communicate power management (PM) events </h2>
<p>Uvmm can be instructed to inform a PM manager of PM events through the <a class="el" href="classL4_1_1Platform__control.html" title="L4 C++ interface for controlling platform-wide properties. ">L4::Platform_control</a> interface. To that end, uvmm may be equipped with a <code>pfc</code> cap. On suspend, uvmm will call <a class="el" href="group__l4__platform__control__api.html#ga56b855fa63a3d94b275bdd17bb0bc21e" title="Enter suspend to RAM. ">l4_platform_ctl_system_suspend()</a>.</p>
<p>The <code>pfc</code> cap can also be implemented by IO. In that case the guest can start a machine suspend/shutdown/reboot.</p>
<h2>KVM clock for uvmm/amd64 guests </h2>
<p>When executing <a class="el" href="namespaceL4Re.html" title="L4Re C++ Interfaces. ">L4Re</a> + uvmm on QEMU, the PIT as clock source is not reliable. The paravirtualized KVM clock provides the guest with a stable clock source.</p>
<p>A KVM clock device is available to the guest, if the device tree contains the corresponding entry: </p><pre class="fragment">kvm_clock {
    compatible = "kvm-clock";
    reg = &lt;0x0 0x0 0x0 0x0&gt;;
};
</pre><p>To make use of this clock, the Linux guest must be built with the following configuration options:</p>
<p>CONFIG_HYPERVISOR_GUEST=y CONFIG_KVM_GUEST=y CONFIG_PTP_1588_CLOCK_KVM is not set</p>
<p>Note: KVM calls besides the KVM clock are unhandled and lead to failure in the uvmm, e.g. vmcall 0x9 for the PTP_1588_CLOCK_KVM.</p>
<p>This is considered a development feature. The KVM clock is not required when running on physical hardware as TSC calibration via the PIT works as expected. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="l4re_servers.html">L4Re Servers</a></li>
    <li class="footer">Generated on Sun Nov 25 2018 13:45:54 for L4Re - L4 Runtime Environment by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
